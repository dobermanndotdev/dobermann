// Code generated by SQLBoiler 4.14.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Monitor is an object representing the database table.
type Monitor struct {
	ID                          string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	Endpoint                    string      `boil:"endpoint" json:"endpoint" toml:"endpoint" yaml:"endpoint"`
	RecoveredOnlyAfter          int16       `boil:"recovered_only_after" json:"recovered_only_after" toml:"recovered_only_after" yaml:"recovered_only_after"`
	StartAnIncidentAfter        int16       `boil:"start_an_incident_after" json:"start_an_incident_after" toml:"start_an_incident_after" yaml:"start_an_incident_after"`
	CheckInterval               int16       `boil:"check_interval" json:"check_interval" toml:"check_interval" yaml:"check_interval"`
	AlertDomainExpirationWithin int16       `boil:"alert_domain_expiration_within" json:"alert_domain_expiration_within" toml:"alert_domain_expiration_within" yaml:"alert_domain_expiration_within"`
	SSLVerificationEnabled      bool        `boil:"ssl_verification_enabled" json:"ssl_verification_enabled" toml:"ssl_verification_enabled" yaml:"ssl_verification_enabled"`
	VerifySSLExpirationWithin   null.Int16  `boil:"verify_ssl_expiration_within" json:"verify_ssl_expiration_within,omitempty" toml:"verify_ssl_expiration_within" yaml:"verify_ssl_expiration_within,omitempty"`
	RequestMethod               string      `boil:"request_method" json:"request_method" toml:"request_method" yaml:"request_method"`
	RequestTimeout              int         `boil:"request_timeout" json:"request_timeout" toml:"request_timeout" yaml:"request_timeout"`
	RequestBody                 null.String `boil:"request_body" json:"request_body,omitempty" toml:"request_body" yaml:"request_body,omitempty"`
	FollowRedirects             bool        `boil:"follow_redirects" json:"follow_redirects" toml:"follow_redirects" yaml:"follow_redirects"`
	KeepCookiesWhileRedirecting bool        `boil:"keep_cookies_while_redirecting" json:"keep_cookies_while_redirecting" toml:"keep_cookies_while_redirecting" yaml:"keep_cookies_while_redirecting"`
	ExpectedResponseStatus      int         `boil:"expected_response_status" json:"expected_response_status" toml:"expected_response_status" yaml:"expected_response_status"`
	BasicAuthUsername           null.String `boil:"basic_auth_username" json:"basic_auth_username,omitempty" toml:"basic_auth_username" yaml:"basic_auth_username,omitempty"`
	BasicAuthPassword           null.String `boil:"basic_auth_password" json:"basic_auth_password,omitempty" toml:"basic_auth_password" yaml:"basic_auth_password,omitempty"`
	MaintenanceFrom             null.Time   `boil:"maintenance_from" json:"maintenance_from,omitempty" toml:"maintenance_from" yaml:"maintenance_from,omitempty"`
	MaintenanceTo               null.Time   `boil:"maintenance_to" json:"maintenance_to,omitempty" toml:"maintenance_to" yaml:"maintenance_to,omitempty"`
	IsUp                        bool        `boil:"is_up" json:"is_up" toml:"is_up" yaml:"is_up"`
	IsPaused                    bool        `boil:"is_paused" json:"is_paused" toml:"is_paused" yaml:"is_paused"`
	AccountID                   string      `boil:"account_id" json:"account_id" toml:"account_id" yaml:"account_id"`
	TeamID                      string      `boil:"team_id" json:"team_id" toml:"team_id" yaml:"team_id"`
	CreatedAt                   time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	LastCheckedAt               time.Time   `boil:"last_checked_at" json:"last_checked_at" toml:"last_checked_at" yaml:"last_checked_at"`
	CheckStatus                 string      `boil:"check_status" json:"check_status" toml:"check_status" yaml:"check_status"`

	R *monitorR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L monitorL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var MonitorColumns = struct {
	ID                          string
	Endpoint                    string
	RecoveredOnlyAfter          string
	StartAnIncidentAfter        string
	CheckInterval               string
	AlertDomainExpirationWithin string
	SSLVerificationEnabled      string
	VerifySSLExpirationWithin   string
	RequestMethod               string
	RequestTimeout              string
	RequestBody                 string
	FollowRedirects             string
	KeepCookiesWhileRedirecting string
	ExpectedResponseStatus      string
	BasicAuthUsername           string
	BasicAuthPassword           string
	MaintenanceFrom             string
	MaintenanceTo               string
	IsUp                        string
	IsPaused                    string
	AccountID                   string
	TeamID                      string
	CreatedAt                   string
	LastCheckedAt               string
	CheckStatus                 string
}{
	ID:                          "id",
	Endpoint:                    "endpoint",
	RecoveredOnlyAfter:          "recovered_only_after",
	StartAnIncidentAfter:        "start_an_incident_after",
	CheckInterval:               "check_interval",
	AlertDomainExpirationWithin: "alert_domain_expiration_within",
	SSLVerificationEnabled:      "ssl_verification_enabled",
	VerifySSLExpirationWithin:   "verify_ssl_expiration_within",
	RequestMethod:               "request_method",
	RequestTimeout:              "request_timeout",
	RequestBody:                 "request_body",
	FollowRedirects:             "follow_redirects",
	KeepCookiesWhileRedirecting: "keep_cookies_while_redirecting",
	ExpectedResponseStatus:      "expected_response_status",
	BasicAuthUsername:           "basic_auth_username",
	BasicAuthPassword:           "basic_auth_password",
	MaintenanceFrom:             "maintenance_from",
	MaintenanceTo:               "maintenance_to",
	IsUp:                        "is_up",
	IsPaused:                    "is_paused",
	AccountID:                   "account_id",
	TeamID:                      "team_id",
	CreatedAt:                   "created_at",
	LastCheckedAt:               "last_checked_at",
	CheckStatus:                 "check_status",
}

var MonitorTableColumns = struct {
	ID                          string
	Endpoint                    string
	RecoveredOnlyAfter          string
	StartAnIncidentAfter        string
	CheckInterval               string
	AlertDomainExpirationWithin string
	SSLVerificationEnabled      string
	VerifySSLExpirationWithin   string
	RequestMethod               string
	RequestTimeout              string
	RequestBody                 string
	FollowRedirects             string
	KeepCookiesWhileRedirecting string
	ExpectedResponseStatus      string
	BasicAuthUsername           string
	BasicAuthPassword           string
	MaintenanceFrom             string
	MaintenanceTo               string
	IsUp                        string
	IsPaused                    string
	AccountID                   string
	TeamID                      string
	CreatedAt                   string
	LastCheckedAt               string
	CheckStatus                 string
}{
	ID:                          "monitors.id",
	Endpoint:                    "monitors.endpoint",
	RecoveredOnlyAfter:          "monitors.recovered_only_after",
	StartAnIncidentAfter:        "monitors.start_an_incident_after",
	CheckInterval:               "monitors.check_interval",
	AlertDomainExpirationWithin: "monitors.alert_domain_expiration_within",
	SSLVerificationEnabled:      "monitors.ssl_verification_enabled",
	VerifySSLExpirationWithin:   "monitors.verify_ssl_expiration_within",
	RequestMethod:               "monitors.request_method",
	RequestTimeout:              "monitors.request_timeout",
	RequestBody:                 "monitors.request_body",
	FollowRedirects:             "monitors.follow_redirects",
	KeepCookiesWhileRedirecting: "monitors.keep_cookies_while_redirecting",
	ExpectedResponseStatus:      "monitors.expected_response_status",
	BasicAuthUsername:           "monitors.basic_auth_username",
	BasicAuthPassword:           "monitors.basic_auth_password",
	MaintenanceFrom:             "monitors.maintenance_from",
	MaintenanceTo:               "monitors.maintenance_to",
	IsUp:                        "monitors.is_up",
	IsPaused:                    "monitors.is_paused",
	AccountID:                   "monitors.account_id",
	TeamID:                      "monitors.team_id",
	CreatedAt:                   "monitors.created_at",
	LastCheckedAt:               "monitors.last_checked_at",
	CheckStatus:                 "monitors.check_status",
}

// Generated where

type whereHelperint16 struct{ field string }

func (w whereHelperint16) EQ(x int16) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint16) NEQ(x int16) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint16) LT(x int16) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint16) LTE(x int16) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint16) GT(x int16) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint16) GTE(x int16) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint16) IN(slice []int16) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint16) NIN(slice []int16) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelperbool struct{ field string }

func (w whereHelperbool) EQ(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperbool) NEQ(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperbool) LT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperbool) LTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperbool) GT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperbool) GTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

type whereHelpernull_Int16 struct{ field string }

func (w whereHelpernull_Int16) EQ(x null.Int16) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int16) NEQ(x null.Int16) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int16) LT(x null.Int16) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int16) LTE(x null.Int16) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int16) GT(x null.Int16) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int16) GTE(x null.Int16) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Int16) IN(slice []int16) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Int16) NIN(slice []int16) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Int16) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int16) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpernull_String struct{ field string }

func (w whereHelpernull_String) EQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_String) NEQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_String) LT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_String) LTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_String) GT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_String) GTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_String) IN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_String) NIN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_String) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_String) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpernull_Time struct{ field string }

func (w whereHelpernull_Time) EQ(x null.Time) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Time) NEQ(x null.Time) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Time) LT(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Time) LTE(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Time) GT(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Time) GTE(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_Time) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Time) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var MonitorWhere = struct {
	ID                          whereHelperstring
	Endpoint                    whereHelperstring
	RecoveredOnlyAfter          whereHelperint16
	StartAnIncidentAfter        whereHelperint16
	CheckInterval               whereHelperint16
	AlertDomainExpirationWithin whereHelperint16
	SSLVerificationEnabled      whereHelperbool
	VerifySSLExpirationWithin   whereHelpernull_Int16
	RequestMethod               whereHelperstring
	RequestTimeout              whereHelperint
	RequestBody                 whereHelpernull_String
	FollowRedirects             whereHelperbool
	KeepCookiesWhileRedirecting whereHelperbool
	ExpectedResponseStatus      whereHelperint
	BasicAuthUsername           whereHelpernull_String
	BasicAuthPassword           whereHelpernull_String
	MaintenanceFrom             whereHelpernull_Time
	MaintenanceTo               whereHelpernull_Time
	IsUp                        whereHelperbool
	IsPaused                    whereHelperbool
	AccountID                   whereHelperstring
	TeamID                      whereHelperstring
	CreatedAt                   whereHelpertime_Time
	LastCheckedAt               whereHelpertime_Time
	CheckStatus                 whereHelperstring
}{
	ID:                          whereHelperstring{field: "\"monitors\".\"id\""},
	Endpoint:                    whereHelperstring{field: "\"monitors\".\"endpoint\""},
	RecoveredOnlyAfter:          whereHelperint16{field: "\"monitors\".\"recovered_only_after\""},
	StartAnIncidentAfter:        whereHelperint16{field: "\"monitors\".\"start_an_incident_after\""},
	CheckInterval:               whereHelperint16{field: "\"monitors\".\"check_interval\""},
	AlertDomainExpirationWithin: whereHelperint16{field: "\"monitors\".\"alert_domain_expiration_within\""},
	SSLVerificationEnabled:      whereHelperbool{field: "\"monitors\".\"ssl_verification_enabled\""},
	VerifySSLExpirationWithin:   whereHelpernull_Int16{field: "\"monitors\".\"verify_ssl_expiration_within\""},
	RequestMethod:               whereHelperstring{field: "\"monitors\".\"request_method\""},
	RequestTimeout:              whereHelperint{field: "\"monitors\".\"request_timeout\""},
	RequestBody:                 whereHelpernull_String{field: "\"monitors\".\"request_body\""},
	FollowRedirects:             whereHelperbool{field: "\"monitors\".\"follow_redirects\""},
	KeepCookiesWhileRedirecting: whereHelperbool{field: "\"monitors\".\"keep_cookies_while_redirecting\""},
	ExpectedResponseStatus:      whereHelperint{field: "\"monitors\".\"expected_response_status\""},
	BasicAuthUsername:           whereHelpernull_String{field: "\"monitors\".\"basic_auth_username\""},
	BasicAuthPassword:           whereHelpernull_String{field: "\"monitors\".\"basic_auth_password\""},
	MaintenanceFrom:             whereHelpernull_Time{field: "\"monitors\".\"maintenance_from\""},
	MaintenanceTo:               whereHelpernull_Time{field: "\"monitors\".\"maintenance_to\""},
	IsUp:                        whereHelperbool{field: "\"monitors\".\"is_up\""},
	IsPaused:                    whereHelperbool{field: "\"monitors\".\"is_paused\""},
	AccountID:                   whereHelperstring{field: "\"monitors\".\"account_id\""},
	TeamID:                      whereHelperstring{field: "\"monitors\".\"team_id\""},
	CreatedAt:                   whereHelpertime_Time{field: "\"monitors\".\"created_at\""},
	LastCheckedAt:               whereHelpertime_Time{field: "\"monitors\".\"last_checked_at\""},
	CheckStatus:                 whereHelperstring{field: "\"monitors\".\"check_status\""},
}

// MonitorRels is where relationship names are stored.
var MonitorRels = struct {
	Account               string
	Team                  string
	MonitorCheckResults   string
	Regions               string
	MonitorRequestHeaders string
}{
	Account:               "Account",
	Team:                  "Team",
	MonitorCheckResults:   "MonitorCheckResults",
	Regions:               "Regions",
	MonitorRequestHeaders: "MonitorRequestHeaders",
}

// monitorR is where relationships are stored.
type monitorR struct {
	Account               *Account                  `boil:"Account" json:"Account" toml:"Account" yaml:"Account"`
	Team                  *Team                     `boil:"Team" json:"Team" toml:"Team" yaml:"Team"`
	MonitorCheckResults   MonitorCheckResultSlice   `boil:"MonitorCheckResults" json:"MonitorCheckResults" toml:"MonitorCheckResults" yaml:"MonitorCheckResults"`
	Regions               RegionSlice               `boil:"Regions" json:"Regions" toml:"Regions" yaml:"Regions"`
	MonitorRequestHeaders MonitorRequestHeaderSlice `boil:"MonitorRequestHeaders" json:"MonitorRequestHeaders" toml:"MonitorRequestHeaders" yaml:"MonitorRequestHeaders"`
}

// NewStruct creates a new relationship struct
func (*monitorR) NewStruct() *monitorR {
	return &monitorR{}
}

func (r *monitorR) GetAccount() *Account {
	if r == nil {
		return nil
	}
	return r.Account
}

func (r *monitorR) GetTeam() *Team {
	if r == nil {
		return nil
	}
	return r.Team
}

func (r *monitorR) GetMonitorCheckResults() MonitorCheckResultSlice {
	if r == nil {
		return nil
	}
	return r.MonitorCheckResults
}

func (r *monitorR) GetRegions() RegionSlice {
	if r == nil {
		return nil
	}
	return r.Regions
}

func (r *monitorR) GetMonitorRequestHeaders() MonitorRequestHeaderSlice {
	if r == nil {
		return nil
	}
	return r.MonitorRequestHeaders
}

// monitorL is where Load methods for each relationship are stored.
type monitorL struct{}

var (
	monitorAllColumns            = []string{"id", "endpoint", "recovered_only_after", "start_an_incident_after", "check_interval", "alert_domain_expiration_within", "ssl_verification_enabled", "verify_ssl_expiration_within", "request_method", "request_timeout", "request_body", "follow_redirects", "keep_cookies_while_redirecting", "expected_response_status", "basic_auth_username", "basic_auth_password", "maintenance_from", "maintenance_to", "is_up", "is_paused", "account_id", "team_id", "created_at", "last_checked_at", "check_status"}
	monitorColumnsWithoutDefault = []string{"id", "endpoint", "recovered_only_after", "start_an_incident_after", "check_interval", "alert_domain_expiration_within", "request_timeout", "expected_response_status", "account_id", "team_id"}
	monitorColumnsWithDefault    = []string{"ssl_verification_enabled", "verify_ssl_expiration_within", "request_method", "request_body", "follow_redirects", "keep_cookies_while_redirecting", "basic_auth_username", "basic_auth_password", "maintenance_from", "maintenance_to", "is_up", "is_paused", "created_at", "last_checked_at", "check_status"}
	monitorPrimaryKeyColumns     = []string{"id"}
	monitorGeneratedColumns      = []string{}
)

type (
	// MonitorSlice is an alias for a slice of pointers to Monitor.
	// This should almost always be used instead of []Monitor.
	MonitorSlice []*Monitor
	// MonitorHook is the signature for custom Monitor hook methods
	MonitorHook func(context.Context, boil.ContextExecutor, *Monitor) error

	monitorQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	monitorType                 = reflect.TypeOf(&Monitor{})
	monitorMapping              = queries.MakeStructMapping(monitorType)
	monitorPrimaryKeyMapping, _ = queries.BindMapping(monitorType, monitorMapping, monitorPrimaryKeyColumns)
	monitorInsertCacheMut       sync.RWMutex
	monitorInsertCache          = make(map[string]insertCache)
	monitorUpdateCacheMut       sync.RWMutex
	monitorUpdateCache          = make(map[string]updateCache)
	monitorUpsertCacheMut       sync.RWMutex
	monitorUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var monitorAfterSelectHooks []MonitorHook

var monitorBeforeInsertHooks []MonitorHook
var monitorAfterInsertHooks []MonitorHook

var monitorBeforeUpdateHooks []MonitorHook
var monitorAfterUpdateHooks []MonitorHook

var monitorBeforeDeleteHooks []MonitorHook
var monitorAfterDeleteHooks []MonitorHook

var monitorBeforeUpsertHooks []MonitorHook
var monitorAfterUpsertHooks []MonitorHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Monitor) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range monitorAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Monitor) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range monitorBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Monitor) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range monitorAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Monitor) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range monitorBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Monitor) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range monitorAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Monitor) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range monitorBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Monitor) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range monitorAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Monitor) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range monitorBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Monitor) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range monitorAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddMonitorHook registers your hook function for all future operations.
func AddMonitorHook(hookPoint boil.HookPoint, monitorHook MonitorHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		monitorAfterSelectHooks = append(monitorAfterSelectHooks, monitorHook)
	case boil.BeforeInsertHook:
		monitorBeforeInsertHooks = append(monitorBeforeInsertHooks, monitorHook)
	case boil.AfterInsertHook:
		monitorAfterInsertHooks = append(monitorAfterInsertHooks, monitorHook)
	case boil.BeforeUpdateHook:
		monitorBeforeUpdateHooks = append(monitorBeforeUpdateHooks, monitorHook)
	case boil.AfterUpdateHook:
		monitorAfterUpdateHooks = append(monitorAfterUpdateHooks, monitorHook)
	case boil.BeforeDeleteHook:
		monitorBeforeDeleteHooks = append(monitorBeforeDeleteHooks, monitorHook)
	case boil.AfterDeleteHook:
		monitorAfterDeleteHooks = append(monitorAfterDeleteHooks, monitorHook)
	case boil.BeforeUpsertHook:
		monitorBeforeUpsertHooks = append(monitorBeforeUpsertHooks, monitorHook)
	case boil.AfterUpsertHook:
		monitorAfterUpsertHooks = append(monitorAfterUpsertHooks, monitorHook)
	}
}

// One returns a single monitor record from the query.
func (q monitorQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Monitor, error) {
	o := &Monitor{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for monitors")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Monitor records from the query.
func (q monitorQuery) All(ctx context.Context, exec boil.ContextExecutor) (MonitorSlice, error) {
	var o []*Monitor

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Monitor slice")
	}

	if len(monitorAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Monitor records in the query.
func (q monitorQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count monitors rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q monitorQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if monitors exists")
	}

	return count > 0, nil
}

// Account pointed to by the foreign key.
func (o *Monitor) Account(mods ...qm.QueryMod) accountQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.AccountID),
	}

	queryMods = append(queryMods, mods...)

	return Accounts(queryMods...)
}

// Team pointed to by the foreign key.
func (o *Monitor) Team(mods ...qm.QueryMod) teamQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.TeamID),
	}

	queryMods = append(queryMods, mods...)

	return Teams(queryMods...)
}

// MonitorCheckResults retrieves all the monitor_check_result's MonitorCheckResults with an executor.
func (o *Monitor) MonitorCheckResults(mods ...qm.QueryMod) monitorCheckResultQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"monitor_check_results\".\"monitor_id\"=?", o.ID),
	)

	return MonitorCheckResults(queryMods...)
}

// Regions retrieves all the region's Regions with an executor.
func (o *Monitor) Regions(mods ...qm.QueryMod) regionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.InnerJoin("\"monitor_regions\" on \"regions\".\"id\" = \"monitor_regions\".\"region_id\""),
		qm.Where("\"monitor_regions\".\"monitor_id\"=?", o.ID),
	)

	return Regions(queryMods...)
}

// MonitorRequestHeaders retrieves all the monitor_request_header's MonitorRequestHeaders with an executor.
func (o *Monitor) MonitorRequestHeaders(mods ...qm.QueryMod) monitorRequestHeaderQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"monitor_request_headers\".\"monitor_id\"=?", o.ID),
	)

	return MonitorRequestHeaders(queryMods...)
}

// LoadAccount allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (monitorL) LoadAccount(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMonitor interface{}, mods queries.Applicator) error {
	var slice []*Monitor
	var object *Monitor

	if singular {
		var ok bool
		object, ok = maybeMonitor.(*Monitor)
		if !ok {
			object = new(Monitor)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMonitor)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMonitor))
			}
		}
	} else {
		s, ok := maybeMonitor.(*[]*Monitor)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMonitor)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMonitor))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &monitorR{}
		}
		args = append(args, object.AccountID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &monitorR{}
			}

			for _, a := range args {
				if a == obj.AccountID {
					continue Outer
				}
			}

			args = append(args, obj.AccountID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`accounts`),
		qm.WhereIn(`accounts.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Account")
	}

	var resultSlice []*Account
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Account")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for accounts")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for accounts")
	}

	if len(accountAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Account = foreign
		if foreign.R == nil {
			foreign.R = &accountR{}
		}
		foreign.R.Monitors = append(foreign.R.Monitors, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.AccountID == foreign.ID {
				local.R.Account = foreign
				if foreign.R == nil {
					foreign.R = &accountR{}
				}
				foreign.R.Monitors = append(foreign.R.Monitors, local)
				break
			}
		}
	}

	return nil
}

// LoadTeam allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (monitorL) LoadTeam(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMonitor interface{}, mods queries.Applicator) error {
	var slice []*Monitor
	var object *Monitor

	if singular {
		var ok bool
		object, ok = maybeMonitor.(*Monitor)
		if !ok {
			object = new(Monitor)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMonitor)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMonitor))
			}
		}
	} else {
		s, ok := maybeMonitor.(*[]*Monitor)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMonitor)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMonitor))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &monitorR{}
		}
		args = append(args, object.TeamID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &monitorR{}
			}

			for _, a := range args {
				if a == obj.TeamID {
					continue Outer
				}
			}

			args = append(args, obj.TeamID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`teams`),
		qm.WhereIn(`teams.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Team")
	}

	var resultSlice []*Team
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Team")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for teams")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for teams")
	}

	if len(teamAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Team = foreign
		if foreign.R == nil {
			foreign.R = &teamR{}
		}
		foreign.R.Monitors = append(foreign.R.Monitors, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.TeamID == foreign.ID {
				local.R.Team = foreign
				if foreign.R == nil {
					foreign.R = &teamR{}
				}
				foreign.R.Monitors = append(foreign.R.Monitors, local)
				break
			}
		}
	}

	return nil
}

// LoadMonitorCheckResults allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (monitorL) LoadMonitorCheckResults(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMonitor interface{}, mods queries.Applicator) error {
	var slice []*Monitor
	var object *Monitor

	if singular {
		var ok bool
		object, ok = maybeMonitor.(*Monitor)
		if !ok {
			object = new(Monitor)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMonitor)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMonitor))
			}
		}
	} else {
		s, ok := maybeMonitor.(*[]*Monitor)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMonitor)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMonitor))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &monitorR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &monitorR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`monitor_check_results`),
		qm.WhereIn(`monitor_check_results.monitor_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load monitor_check_results")
	}

	var resultSlice []*MonitorCheckResult
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice monitor_check_results")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on monitor_check_results")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for monitor_check_results")
	}

	if len(monitorCheckResultAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.MonitorCheckResults = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &monitorCheckResultR{}
			}
			foreign.R.Monitor = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.MonitorID {
				local.R.MonitorCheckResults = append(local.R.MonitorCheckResults, foreign)
				if foreign.R == nil {
					foreign.R = &monitorCheckResultR{}
				}
				foreign.R.Monitor = local
				break
			}
		}
	}

	return nil
}

// LoadRegions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (monitorL) LoadRegions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMonitor interface{}, mods queries.Applicator) error {
	var slice []*Monitor
	var object *Monitor

	if singular {
		var ok bool
		object, ok = maybeMonitor.(*Monitor)
		if !ok {
			object = new(Monitor)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMonitor)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMonitor))
			}
		}
	} else {
		s, ok := maybeMonitor.(*[]*Monitor)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMonitor)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMonitor))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &monitorR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &monitorR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.Select("\"regions\".\"id\", \"regions\".\"name\", \"a\".\"monitor_id\""),
		qm.From("\"regions\""),
		qm.InnerJoin("\"monitor_regions\" as \"a\" on \"regions\".\"id\" = \"a\".\"region_id\""),
		qm.WhereIn("\"a\".\"monitor_id\" in ?", args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load regions")
	}

	var resultSlice []*Region

	var localJoinCols []string
	for results.Next() {
		one := new(Region)
		var localJoinCol string

		err = results.Scan(&one.ID, &one.Name, &localJoinCol)
		if err != nil {
			return errors.Wrap(err, "failed to scan eager loaded results for regions")
		}
		if err = results.Err(); err != nil {
			return errors.Wrap(err, "failed to plebian-bind eager loaded slice regions")
		}

		resultSlice = append(resultSlice, one)
		localJoinCols = append(localJoinCols, localJoinCol)
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on regions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for regions")
	}

	if len(regionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Regions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &regionR{}
			}
			foreign.R.Monitors = append(foreign.R.Monitors, object)
		}
		return nil
	}

	for i, foreign := range resultSlice {
		localJoinCol := localJoinCols[i]
		for _, local := range slice {
			if local.ID == localJoinCol {
				local.R.Regions = append(local.R.Regions, foreign)
				if foreign.R == nil {
					foreign.R = &regionR{}
				}
				foreign.R.Monitors = append(foreign.R.Monitors, local)
				break
			}
		}
	}

	return nil
}

// LoadMonitorRequestHeaders allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (monitorL) LoadMonitorRequestHeaders(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMonitor interface{}, mods queries.Applicator) error {
	var slice []*Monitor
	var object *Monitor

	if singular {
		var ok bool
		object, ok = maybeMonitor.(*Monitor)
		if !ok {
			object = new(Monitor)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMonitor)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMonitor))
			}
		}
	} else {
		s, ok := maybeMonitor.(*[]*Monitor)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMonitor)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMonitor))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &monitorR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &monitorR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`monitor_request_headers`),
		qm.WhereIn(`monitor_request_headers.monitor_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load monitor_request_headers")
	}

	var resultSlice []*MonitorRequestHeader
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice monitor_request_headers")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on monitor_request_headers")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for monitor_request_headers")
	}

	if len(monitorRequestHeaderAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.MonitorRequestHeaders = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &monitorRequestHeaderR{}
			}
			foreign.R.Monitor = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.MonitorID {
				local.R.MonitorRequestHeaders = append(local.R.MonitorRequestHeaders, foreign)
				if foreign.R == nil {
					foreign.R = &monitorRequestHeaderR{}
				}
				foreign.R.Monitor = local
				break
			}
		}
	}

	return nil
}

// SetAccount of the monitor to the related item.
// Sets o.R.Account to related.
// Adds o to related.R.Monitors.
func (o *Monitor) SetAccount(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Account) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"monitors\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"account_id"}),
		strmangle.WhereClause("\"", "\"", 2, monitorPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.AccountID = related.ID
	if o.R == nil {
		o.R = &monitorR{
			Account: related,
		}
	} else {
		o.R.Account = related
	}

	if related.R == nil {
		related.R = &accountR{
			Monitors: MonitorSlice{o},
		}
	} else {
		related.R.Monitors = append(related.R.Monitors, o)
	}

	return nil
}

// SetTeam of the monitor to the related item.
// Sets o.R.Team to related.
// Adds o to related.R.Monitors.
func (o *Monitor) SetTeam(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Team) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"monitors\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"team_id"}),
		strmangle.WhereClause("\"", "\"", 2, monitorPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.TeamID = related.ID
	if o.R == nil {
		o.R = &monitorR{
			Team: related,
		}
	} else {
		o.R.Team = related
	}

	if related.R == nil {
		related.R = &teamR{
			Monitors: MonitorSlice{o},
		}
	} else {
		related.R.Monitors = append(related.R.Monitors, o)
	}

	return nil
}

// AddMonitorCheckResults adds the given related objects to the existing relationships
// of the monitor, optionally inserting them as new records.
// Appends related to o.R.MonitorCheckResults.
// Sets related.R.Monitor appropriately.
func (o *Monitor) AddMonitorCheckResults(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MonitorCheckResult) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.MonitorID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"monitor_check_results\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"monitor_id"}),
				strmangle.WhereClause("\"", "\"", 2, monitorCheckResultPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.MonitorID = o.ID
		}
	}

	if o.R == nil {
		o.R = &monitorR{
			MonitorCheckResults: related,
		}
	} else {
		o.R.MonitorCheckResults = append(o.R.MonitorCheckResults, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &monitorCheckResultR{
				Monitor: o,
			}
		} else {
			rel.R.Monitor = o
		}
	}
	return nil
}

// AddRegions adds the given related objects to the existing relationships
// of the monitor, optionally inserting them as new records.
// Appends related to o.R.Regions.
// Sets related.R.Monitors appropriately.
func (o *Monitor) AddRegions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Region) error {
	var err error
	for _, rel := range related {
		if insert {
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		}
	}

	for _, rel := range related {
		query := "insert into \"monitor_regions\" (\"monitor_id\", \"region_id\") values ($1, $2)"
		values := []interface{}{o.ID, rel.ID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, query)
			fmt.Fprintln(writer, values)
		}
		_, err = exec.ExecContext(ctx, query, values...)
		if err != nil {
			return errors.Wrap(err, "failed to insert into join table")
		}
	}
	if o.R == nil {
		o.R = &monitorR{
			Regions: related,
		}
	} else {
		o.R.Regions = append(o.R.Regions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &regionR{
				Monitors: MonitorSlice{o},
			}
		} else {
			rel.R.Monitors = append(rel.R.Monitors, o)
		}
	}
	return nil
}

// SetRegions removes all previously related items of the
// monitor replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Monitors's Regions accordingly.
// Replaces o.R.Regions with related.
// Sets related.R.Monitors's Regions accordingly.
func (o *Monitor) SetRegions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Region) error {
	query := "delete from \"monitor_regions\" where \"monitor_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	removeRegionsFromMonitorsSlice(o, related)
	if o.R != nil {
		o.R.Regions = nil
	}

	return o.AddRegions(ctx, exec, insert, related...)
}

// RemoveRegions relationships from objects passed in.
// Removes related items from R.Regions (uses pointer comparison, removal does not keep order)
// Sets related.R.Monitors.
func (o *Monitor) RemoveRegions(ctx context.Context, exec boil.ContextExecutor, related ...*Region) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	query := fmt.Sprintf(
		"delete from \"monitor_regions\" where \"monitor_id\" = $1 and \"region_id\" in (%s)",
		strmangle.Placeholders(dialect.UseIndexPlaceholders, len(related), 2, 1),
	)
	values := []interface{}{o.ID}
	for _, rel := range related {
		values = append(values, rel.ID)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err = exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}
	removeRegionsFromMonitorsSlice(o, related)
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Regions {
			if rel != ri {
				continue
			}

			ln := len(o.R.Regions)
			if ln > 1 && i < ln-1 {
				o.R.Regions[i] = o.R.Regions[ln-1]
			}
			o.R.Regions = o.R.Regions[:ln-1]
			break
		}
	}

	return nil
}

func removeRegionsFromMonitorsSlice(o *Monitor, related []*Region) {
	for _, rel := range related {
		if rel.R == nil {
			continue
		}
		for i, ri := range rel.R.Monitors {
			if o.ID != ri.ID {
				continue
			}

			ln := len(rel.R.Monitors)
			if ln > 1 && i < ln-1 {
				rel.R.Monitors[i] = rel.R.Monitors[ln-1]
			}
			rel.R.Monitors = rel.R.Monitors[:ln-1]
			break
		}
	}
}

// AddMonitorRequestHeaders adds the given related objects to the existing relationships
// of the monitor, optionally inserting them as new records.
// Appends related to o.R.MonitorRequestHeaders.
// Sets related.R.Monitor appropriately.
func (o *Monitor) AddMonitorRequestHeaders(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MonitorRequestHeader) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.MonitorID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"monitor_request_headers\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"monitor_id"}),
				strmangle.WhereClause("\"", "\"", 2, monitorRequestHeaderPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.MonitorID = o.ID
		}
	}

	if o.R == nil {
		o.R = &monitorR{
			MonitorRequestHeaders: related,
		}
	} else {
		o.R.MonitorRequestHeaders = append(o.R.MonitorRequestHeaders, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &monitorRequestHeaderR{
				Monitor: o,
			}
		} else {
			rel.R.Monitor = o
		}
	}
	return nil
}

// Monitors retrieves all the records using an executor.
func Monitors(mods ...qm.QueryMod) monitorQuery {
	mods = append(mods, qm.From("\"monitors\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"monitors\".*"})
	}

	return monitorQuery{q}
}

// FindMonitor retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindMonitor(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*Monitor, error) {
	monitorObj := &Monitor{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"monitors\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, monitorObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from monitors")
	}

	if err = monitorObj.doAfterSelectHooks(ctx, exec); err != nil {
		return monitorObj, err
	}

	return monitorObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Monitor) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no monitors provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(monitorColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	monitorInsertCacheMut.RLock()
	cache, cached := monitorInsertCache[key]
	monitorInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			monitorAllColumns,
			monitorColumnsWithDefault,
			monitorColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(monitorType, monitorMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(monitorType, monitorMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"monitors\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"monitors\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into monitors")
	}

	if !cached {
		monitorInsertCacheMut.Lock()
		monitorInsertCache[key] = cache
		monitorInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Monitor.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Monitor) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	monitorUpdateCacheMut.RLock()
	cache, cached := monitorUpdateCache[key]
	monitorUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			monitorAllColumns,
			monitorPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update monitors, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"monitors\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, monitorPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(monitorType, monitorMapping, append(wl, monitorPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update monitors row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for monitors")
	}

	if !cached {
		monitorUpdateCacheMut.Lock()
		monitorUpdateCache[key] = cache
		monitorUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q monitorQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for monitors")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for monitors")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o MonitorSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), monitorPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"monitors\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, monitorPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in monitor slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all monitor")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Monitor) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no monitors provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(monitorColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	monitorUpsertCacheMut.RLock()
	cache, cached := monitorUpsertCache[key]
	monitorUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			monitorAllColumns,
			monitorColumnsWithDefault,
			monitorColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			monitorAllColumns,
			monitorPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert monitors, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(monitorPrimaryKeyColumns))
			copy(conflict, monitorPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"monitors\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(monitorType, monitorMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(monitorType, monitorMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert monitors")
	}

	if !cached {
		monitorUpsertCacheMut.Lock()
		monitorUpsertCache[key] = cache
		monitorUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Monitor record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Monitor) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Monitor provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), monitorPrimaryKeyMapping)
	sql := "DELETE FROM \"monitors\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from monitors")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for monitors")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q monitorQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no monitorQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from monitors")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for monitors")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o MonitorSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(monitorBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), monitorPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"monitors\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, monitorPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from monitor slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for monitors")
	}

	if len(monitorAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Monitor) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindMonitor(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *MonitorSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := MonitorSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), monitorPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"monitors\".* FROM \"monitors\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, monitorPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in MonitorSlice")
	}

	*o = slice

	return nil
}

// MonitorExists checks if the Monitor row exists.
func MonitorExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"monitors\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if monitors exists")
	}

	return exists, nil
}

// Exists checks if the Monitor row exists.
func (o *Monitor) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return MonitorExists(ctx, exec, o.ID)
}
